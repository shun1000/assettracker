import { switchCameraImage, toggleTorchImage } from "./assets/base64assets";
import { BarcodePicker } from "./barcodePicker";
import { Camera } from "./camera";
import { CameraAccess } from "./cameraAccess";
import { CameraSettings } from "./cameraSettings";
import { CustomError } from "./customError";

/**
 * @hidden
 *
 * A barcode picker utility class used to handle camera interaction.
 */
export class BarcodePickerCameraManager {
  private static readonly isIOSDevice: boolean = navigator.platform != null &&
    navigator.platform !== "" &&
    /iPad|iPhone|iPod/.test(navigator.platform);
  private static readonly cameraAccessTimeoutMs: number = 4000;
  private static readonly cameraMetadataCheckTimeoutMs: number = 4000;
  private static readonly cameraMetadataCheckIntervalMs: number = 50;
  private static readonly getCapabilitiesTimeoutMs: number = 500;
  private static readonly autofocusIntervalMs: number = 1500;
  private static readonly manualToAutofocusResumeTimeoutMs: number = 5000;
  private static readonly manualFocusRetryTimeoutMs: number = 100;
  public activeCamera: Camera;
  public activeCameraSettings: CameraSettings | undefined;
  private selectedCamera: Camera | undefined;
  private selectedCameraSettings: CameraSettings | undefined;

  private mediaStream: MediaStream | undefined;
  private mediaTrackCapabilities: any | undefined;
  private postStreamInitializationListener: () => void = this.postStreamInitialization.bind(this);
  private triggerManualFocusListener: () => void = this.triggerManualFocus.bind(this);
  private cameraAccessTimeout: number;
  private cameraMetadataCheckInterval: number;
  private getCapabilitiesTimeout: number;
  private autofocusInterval: number;
  private manualToAutofocusResumeTimeout: number;
  private manualFocusRetryTimeout: number;
  private enableCameraSwitcher: boolean;
  private enableTorchToggle: boolean;
  private enableTapToFocus: boolean;
  private torchEnabled: boolean;
  private cameraSwitcherElement: HTMLImageElement;
  private torchToggleElement: HTMLImageElement;

  constructor(private barcodePicker: BarcodePicker) {
    this.setupCameraSwitcher();
    this.setupTorchToggle();
  }

  public setUIOptions(enableCameraSwitcher: boolean, enableTorchToggle: boolean, enableTapToFocus: boolean): void {
    this.enableCameraSwitcher = enableCameraSwitcher;
    this.enableTorchToggle = enableTorchToggle;
    this.enableTapToFocus = enableTapToFocus;
  }

  public setSelectedCamera(camera?: Camera): void {
    this.selectedCamera = camera;
  }

  public setSelectedCameraSettings(cameraSettings?: CameraSettings): void {
    this.selectedCameraSettings = cameraSettings;
  }

  public setupCameras(): Promise<BarcodePicker> {
    return CameraAccess.getCameras().then(cameras => {
      if (this.enableCameraSwitcher && cameras.length > 1) {
        this.cameraSwitcherElement.classList.remove("scandit-hidden");
      }

      if (this.selectedCamera == null) {
        let autoselectedCamera: Camera | undefined = cameras.find(currentCamera => {
          return currentCamera.cameraType === Camera.Type.BACK;
        });
        if (autoselectedCamera === undefined) {
          autoselectedCamera = cameras[0];
        }
        if (autoselectedCamera === undefined) {
          return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
        }

        return this.initializeCameraWithSettings(autoselectedCamera, this.selectedCameraSettings);
      } else {
        return this.initializeCameraWithSettings(this.selectedCamera, this.selectedCameraSettings);
      }
    });
  }

  public stopStream(): void {
    if (this.activeCamera != null) {
      this.activeCamera.currentResolution = undefined;
    }

    if (this.mediaStream != null) {
      window.clearTimeout(this.cameraAccessTimeout);
      window.clearInterval(this.cameraMetadataCheckInterval);
      window.clearTimeout(this.getCapabilitiesTimeout);
      window.clearTimeout(this.manualFocusRetryTimeout);
      window.clearTimeout(this.manualToAutofocusResumeTimeout);
      window.clearInterval(this.autofocusInterval);
      this.mediaStream.getVideoTracks().forEach(track => {
        track.stop();
      });
      this.mediaStream = undefined;
      this.mediaTrackCapabilities = undefined;
    }
  }

  public applyCameraSettings(cameraSettings?: CameraSettings): Promise<BarcodePicker> {
    if (this.activeCamera == null) {
      return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
    }

    return this.initializeCameraWithSettings(this.activeCamera, cameraSettings);
  }

  public reinitializeCamera(): Promise<BarcodePicker> {
    if (this.activeCamera == null) {
      return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
    }

    return this.initializeCameraWithSettings(this.activeCamera, this.activeCameraSettings);
  }

  public initializeCameraWithSettings(camera: Camera, cameraSettings?: CameraSettings): Promise<BarcodePicker> {
    this.activeCameraSettings = cameraSettings;
    if (cameraSettings != null && cameraSettings.resolutionPreference === CameraSettings.ResolutionPreference.FULL_HD) {
      return this.initializeCamera(camera);
    } else {
      return this.initializeCamera(camera, 3);
    }
  }

  public setTorchEnabled(enabled: boolean): void {
    if (this.mediaStream != null && this.mediaTrackCapabilities != null && this.mediaTrackCapabilities.torch) {
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].applyConstraints === "function") {
        videoTracks[0].applyConstraints({ advanced: [<any>{ torch: enabled }] });
      }
    }
  }

  private triggerManualFocus(event?: Event): void {
    if (event != null) {
      event.preventDefault();
    }
    window.clearTimeout(this.manualFocusRetryTimeout);
    window.clearTimeout(this.manualToAutofocusResumeTimeout);
    if (this.mediaStream != null && this.mediaTrackCapabilities != null) {
      const focusModeCapability: string[] = this.mediaTrackCapabilities.focusMode;
      if (focusModeCapability instanceof Array && focusModeCapability.indexOf("single-shot") !== -1) {
        if (focusModeCapability.indexOf("continuous") !== -1 && focusModeCapability.indexOf("manual") !== -1) {
          this.triggerFocusMode("manual")
            .then(() => {
              this.triggerFocusMode("single-shot");
              // Sometimes the previous call fails silently,
              // so we retrigger it shortly afterwards anyways just to be sure. This has no negative consequences.
              this.manualFocusRetryTimeout = window.setTimeout(() => {
                this.triggerFocusMode("single-shot");
              }, BarcodePickerCameraManager.manualFocusRetryTimeoutMs);
            })
            .catch(() => {
              // Ignored
            });

          this.manualToAutofocusResumeTimeout = window.setTimeout(() => {
            this.triggerFocusMode("continuous");
          }, BarcodePickerCameraManager.manualToAutofocusResumeTimeoutMs);
        } else if (focusModeCapability.indexOf("continuous") === -1) {
          window.clearInterval(this.autofocusInterval);

          this.triggerFocusMode("single-shot").catch(() => {
            // Ignored
          });

          this.manualToAutofocusResumeTimeout = window.setTimeout(() => {
            this.autofocusInterval = window.setInterval(
              this.triggerAutoFocus.bind(this),
              BarcodePickerCameraManager.autofocusIntervalMs
            );
          }, BarcodePickerCameraManager.manualToAutofocusResumeTimeoutMs);
        }
      }
    }
  }

  private postStreamInitialization(): void {
    window.clearTimeout(this.getCapabilitiesTimeout);
    this.getCapabilitiesTimeout = window.setTimeout(() => {
      this.storeStreamCapabilities();
      this.setupAutofocus();
      if (
        this.enableTorchToggle &&
        this.mediaStream != null &&
        this.mediaTrackCapabilities != null &&
        this.mediaTrackCapabilities.torch
      ) {
        this.torchToggleElement.classList.remove("scandit-hidden");
      }
    }, BarcodePickerCameraManager.getCapabilitiesTimeoutMs);
  }

  private storeStreamCapabilities(): void {
    if (this.mediaStream != null) {
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].getCapabilities === "function") {
        this.mediaTrackCapabilities = videoTracks[0].getCapabilities();
      }
    }
  }

  private setupAutofocus(): void {
    window.clearTimeout(this.manualFocusRetryTimeout);
    window.clearTimeout(this.manualToAutofocusResumeTimeout);
    if (this.mediaStream != null && this.mediaTrackCapabilities != null) {
      const focusModeCapability: string[] = this.mediaTrackCapabilities.focusMode;
      if (
        focusModeCapability instanceof Array &&
        focusModeCapability.indexOf("continuous") === -1 &&
        focusModeCapability.indexOf("single-shot") !== -1
      ) {
        window.clearInterval(this.autofocusInterval);
        this.autofocusInterval = window.setInterval(
          this.triggerAutoFocus.bind(this),
          BarcodePickerCameraManager.autofocusIntervalMs
        );
      }
    }
  }

  private triggerAutoFocus(): void {
    this.triggerFocusMode("single-shot").catch(() => {
      // Ignored
    });
  }

  private triggerFocusMode(focusMode: string): Promise<void> {
    if (this.mediaStream != null) {
      const videoTracks: MediaStreamTrack[] = this.mediaStream.getVideoTracks();
      if (videoTracks.length !== 0 && typeof videoTracks[0].applyConstraints === "function") {
        return videoTracks[0].applyConstraints({ advanced: [<any>{ focusMode }] });
      }
    }

    return Promise.reject(undefined);
  }

  private initializeCamera(camera: Camera, resolutionFallbackLevel: number = 0): Promise<BarcodePicker> {
    if (camera == null) {
      return Promise.reject(new CustomError({ name: "NoCameraAvailableError", message: "No camera available" }));
    }

    this.stopStream();
    this.torchEnabled = false;
    this.torchToggleElement.classList.add("scandit-hidden");

    return new Promise((resolve, reject) => {
      CameraAccess.accessCameraStream(resolutionFallbackLevel, camera)
        .then(stream => {
          // Detect weird browser behaviour that on unsupported resolution returns a 2x2 video instead
          if (typeof stream.getTracks()[0].getSettings === "function") {
            const mediaTrackSettings: MediaTrackSettings = stream.getTracks()[0].getSettings();
            if (
              mediaTrackSettings.width != null &&
              mediaTrackSettings.height != null &&
              (mediaTrackSettings.width === 2 || mediaTrackSettings.height === 2)
            ) {
              if (resolutionFallbackLevel === 6) {
                return reject(
                  new CustomError({ name: "NotReadableError", message: "Could not initialize camera correctly" })
                );
              } else {
                return this.initializeCamera(camera, resolutionFallbackLevel + 1)
                  .then(() => {
                    return resolve();
                  })
                  .catch(error => {
                    return reject(error);
                  });
              }
            }
          }

          this.mediaStream = stream;

          // This will add the listener only once in the case of multiple calls, identical listeners are ignored
          this.barcodePicker.videoElement.addEventListener("loadedmetadata", this.postStreamInitializationListener);

          if (this.enableTapToFocus) {
            ["touchstart", "mousedown"].forEach(eventName => {
              this.barcodePicker.videoElement.addEventListener(eventName, this.triggerManualFocusListener);
            });
          }

          this.resolveInitializeCamera(camera, resolve, reject);

          this.barcodePicker.videoElement.srcObject = stream;
          this.barcodePicker.videoElement.load();
          const playPromise: Promise<void> = this.barcodePicker.videoElement.play();

          if (playPromise != null) {
            playPromise.catch(() => {
              // Can sometimes cause an incorrect rejection (all is good, ignore).
            });
          }
        })
        .catch(error => {
          if (
            error.name === "PermissionDeniedError" ||
            error.name === "PermissionDismissedError" ||
            error.name === "NotAllowedError" ||
            error.name === "NotFoundError" ||
            error.name === "AbortError"
          ) {
            // Camera is not accessible at all
            return reject(error);
          }
          if (resolutionFallbackLevel < 6) {
            return this.initializeCamera(camera, resolutionFallbackLevel + 1)
              .then(mediaStream => {
                return resolve(mediaStream);
              })
              .catch(error2 => {
                return reject(error2);
              });
          } else {
            return reject(error);
          }
        });
    });
  }

  private resolveInitializeCamera(
    camera: Camera,
    resolve: (value: BarcodePicker) => void,
    reject: (reason?: any) => void
  ): void {
    const cameraNotReadableError: Error = new CustomError({
      name: "NotReadableError",
      message: "Could not initialize camera correctly"
    });

    this.cameraAccessTimeout = window.setTimeout(() => {
      this.stopStream();
      reject(cameraNotReadableError);
    }, BarcodePickerCameraManager.cameraAccessTimeoutMs);

    if (BarcodePickerCameraManager.isIOSDevice) {
      // iOS camera access should always work but can fail to call "later" video callbacks, so we check loadstart
      this.barcodePicker.videoElement.onloadstart = () => {
        (<any>this.barcodePicker.videoElement).onloadstart = null;
        window.clearTimeout(this.cameraAccessTimeout);

        this.activeCamera = camera;
        this.barcodePicker.setMirrorImageEnabled(this.activeCamera.cameraType === Camera.Type.FRONT);

        resolve(this.barcodePicker);
      };
    } else {
      this.barcodePicker.videoElement.onloadeddata = () => {
        (<any>this.barcodePicker.videoElement).onloadeddata = null;
        window.clearTimeout(this.cameraAccessTimeout);

        // Detect weird browser behaviour that on unsupported resolution returns a 2x2 video instead
        // Also detect failed camera access with no error but also no video stream provided
        if (
          this.barcodePicker.videoElement.videoWidth > 2 &&
          this.barcodePicker.videoElement.videoHeight > 2 &&
          this.barcodePicker.videoElement.currentTime > 0
        ) {
          this.activeCamera = camera;
          this.barcodePicker.setMirrorImageEnabled(this.activeCamera.cameraType === Camera.Type.FRONT);

          return resolve(this.barcodePicker);
        }

        const cameraMetadataCheckStartTime: number = performance.now();

        window.clearInterval(this.cameraMetadataCheckInterval);
        this.cameraMetadataCheckInterval = window.setInterval(() => {
          if (
            this.barcodePicker.videoElement.videoWidth === 2 ||
            this.barcodePicker.videoElement.videoHeight === 2 ||
            this.barcodePicker.videoElement.currentTime === 0
          ) {
            if (
              performance.now() - cameraMetadataCheckStartTime >
              BarcodePickerCameraManager.cameraMetadataCheckTimeoutMs
            ) {
              window.clearInterval(this.cameraMetadataCheckInterval);
              this.stopStream();

              return reject(cameraNotReadableError);
            }

            return;
          }

          window.clearInterval(this.cameraMetadataCheckInterval);

          this.activeCamera = camera;
          this.barcodePicker.setMirrorImageEnabled(this.activeCamera.cameraType === Camera.Type.FRONT);

          this.barcodePicker.videoElement.dispatchEvent(new Event("canplay"));

          return resolve(this.barcodePicker);
        }, BarcodePickerCameraManager.cameraMetadataCheckIntervalMs);
      };
    }
  }

  private setupCameraSwitcher(): void {
    this.cameraSwitcherElement = document.createElement("img");
    this.cameraSwitcherElement.src = switchCameraImage;
    this.cameraSwitcherElement.className = BarcodePicker.cameraSwitcherElementClassName;
    this.cameraSwitcherElement.classList.add("scandit-hidden");
    this.barcodePicker.parentElement.appendChild(this.cameraSwitcherElement);
    ["touchstart", "mousedown"].forEach(eventName => {
      this.cameraSwitcherElement.addEventListener(eventName, event => {
        event.preventDefault();
        CameraAccess.getCameras()
          .then(cameras => {
            const newCameraIndex: number =
              (cameras.findIndex(camera => {
                return camera.deviceId === (this.activeCamera == null ? camera.deviceId : this.activeCamera.deviceId);
              }) +
                1) %
              cameras.length;
            this.initializeCameraWithSettings(cameras[newCameraIndex], this.activeCameraSettings).catch(error => {
              console.error(error);
            });
          })
          .catch(error => {
            console.error(error);
          });
      });
    });
  }

  private setupTorchToggle(): void {
    this.torchToggleElement = document.createElement("img");
    this.torchToggleElement.src = toggleTorchImage;
    this.torchToggleElement.className = BarcodePicker.torchToggleElementClassName;
    this.torchToggleElement.classList.add("scandit-hidden");
    this.barcodePicker.parentElement.appendChild(this.torchToggleElement);
    ["touchstart", "mousedown"].forEach(eventName => {
      this.torchToggleElement.addEventListener(eventName, event => {
        event.preventDefault();
        this.torchEnabled = !this.torchEnabled;
        this.setTorchEnabled(this.torchEnabled);
      });
    });
  }
}
