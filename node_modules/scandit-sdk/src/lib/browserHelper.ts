import { CustomError } from "./customError";

/**
 * @hidden
 */
export namespace BrowserHelper {
  /**
   * @returns The first matching error indicating a missing browser feature, or undefined.
   */
  export function checkBrowserCompatibility(): Error | undefined {
    if (window.navigator.mediaDevices == null || typeof window.navigator.mediaDevices.getUserMedia !== "function") {
      return new CustomError({
        name: "UnsupportedBrowserError",
        message: "Media devices are not supported on this OS / Browser"
      });
    }

    if (!window.hasOwnProperty("Worker") || typeof (<any>window).Worker !== "function") {
      return new CustomError({
        name: "UnsupportedBrowserError",
        message: "Web Worker is not supported on this OS / Browser"
      });
    }

    if (!window.hasOwnProperty("WebAssembly") || typeof (<any>window).WebAssembly !== "object") {
      return new CustomError({
        name: "UnsupportedBrowserError",
        message: "WebAssembly is not supported on this OS / Browser"
      });
    }

    if (!window.hasOwnProperty("Blob") || typeof (<any>window).Blob !== "function") {
      return new CustomError({
        name: "UnsupportedBrowserError",
        message: "Blob object is not supported on this OS / Browser"
      });
    }

    if (
      !window.hasOwnProperty("URL") ||
      (typeof (<any>window).URL !== "function" && typeof (<any>window).URL !== "object") ||
      typeof (<any>window).URL.createObjectURL !== "function"
    ) {
      return new CustomError({
        name: "UnsupportedBrowserError",
        message: "URL object is not supported on this OS / Browser"
      });
    }

    return undefined;
  }

  /**
   * Get a value from a cookie.
   *
   * @param key The key for the cookie for which to get the value.
   * @returns The cookie value for the given key, empty string if not found.
   */
  function getCookieValue(key: string): string {
    const cookieMatch: RegExpMatchArray | null = document.cookie.match(`(^|;)\\s*${key}\\s*=\\s*([^;]+)`);

    if (cookieMatch == null) {
      return "";
    } else {
      const cookieValue: string | undefined = cookieMatch.pop();

      // istanbul ignore next
      return cookieValue == null ? "" : cookieValue;
    }
  }

  /**
   * Store a value in a cookie.
   *
   * @param key The key for the cookie.
   * @param value The value of the cookie.
   * @param expirationDays The amount of days after which the cookie will expire.
   */
  function setCookieValue(key: string, value: string, expirationDays: number): void {
    const date: Date = new Date();
    date.setTime(date.getTime() + expirationDays * 24 * 60 * 60 * 1000);
    document.cookie = `${key}=${value};expires=${date.toUTCString()}`;
  }

  /**
   * Get a device id for the current browser, when available it's retrieved from a cookie,
   * when not it's randomly generated and stored in a cookie to be retrieved by later calls.
   *
   * @returns The device id for the current browser.
   */
  export function getDeviceId(): string {
    const cookieKey: string = "scandit-device-id";
    const storedDeviceId: string = getCookieValue(cookieKey);
    if (storedDeviceId !== "") {
      return storedDeviceId;
    }
    const hexCharacters: string = "0123456789abcdef";
    let randomDeviceId: string = "";
    for (let i: number = 0; i < 40; ++i) {
      // tslint:disable-next-line:insecure-random
      randomDeviceId += hexCharacters.charAt(Math.floor(Math.random() * 16));
    }
    setCookieValue(cookieKey, randomDeviceId, 3650);

    return randomDeviceId;
  }
}
