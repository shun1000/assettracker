"use strict";
/**
 * CameraAccess tests
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
exports.__esModule = true;
var ava_1 = require("ava");
var scandit_sdk_1 = require("scandit-sdk");
var sinon = require("sinon");
var getUserMediaStub = sinon.stub();
var getVideoTracksStub = sinon.stub();
var applyConstraintsStub = sinon.stub();
var getCapabilitiesStub = sinon.stub();
var getConstraintsStub = sinon.stub();
var getSettingsStub = sinon.stub();
var stopStub = sinon.stub();
var getSourcesStub = sinon.stub();
var enumerateDevicesStub = sinon.stub();
var stubs = [
    getUserMediaStub,
    getVideoTracksStub,
    applyConstraintsStub,
    getCapabilitiesStub,
    getConstraintsStub,
    getSettingsStub,
    stopStub,
    getSourcesStub,
    enumerateDevicesStub
];
var fakeCamera1 = {
    deviceId: "1",
    groupId: "1",
    kind: "videoinput",
    label: "Fake Camera Device (back)"
};
var fakeCamera2 = {
    deviceId: "2",
    groupId: "1",
    kind: "videoinput",
    label: "Fake Camera Device (front)"
};
var fakeCamera3 = {
    deviceId: "3",
    groupId: "1",
    kind: "videoinput",
    label: "Fake Camera Device (posteriore)"
};
var fakeCamera4 = {
    deviceId: "4",
    groupId: "1",
    kind: "videoinput",
    label: "Fake Camera Device (unknown)"
};
var fakeCamera5 = {
    deviceId: "5",
    groupId: "1",
    kind: "videoinput",
    label: "Fake Camera Device (unknown)"
};
var illegalFakeCamera1 = {
    deviceId: "10",
    groupId: "1",
    kind: "videoinput"
};
var legacyFakeCamera1 = {
    groupId: "1",
    kind: "videoinput",
    label: "Fake Camera Device (back)"
};
var legacyFakeCamera2 = {
    deviceId: "100",
    groupId: "1",
    kind: "video",
    label: "Fake Camera Device (front)"
};
var fakeMicrophone = {
    deviceId: "1000",
    groupId: "1",
    kind: "audioinput",
    label: "Fake Microhpone Device #2"
};
function fakeCompatibleBrowser() {
    window.navigator.mediaDevices = {
        getUserMedia: getUserMediaStub.resolves({
            getTracks: getVideoTracksStub,
            getVideoTracks: getVideoTracksStub
        })
    };
    getVideoTracksStub.returns([
        {
            applyConstraints: applyConstraintsStub.resolves(),
            getCapabilities: getCapabilitiesStub.returns(123),
            getConstraints: getConstraintsStub.returns(456),
            getSettings: getSettingsStub.returns(789),
            stop: stopStub
        }
    ]);
    window.Worker = function () {
        return;
    };
    window.WebAssembly = {};
    window.Blob = function () {
        return;
    };
    window.URL = {
        createObjectURL: function () {
            return;
        }
    };
}
function resetStubs() {
    stubs.forEach(function (mock) {
        mock.resetHistory();
    });
}
ava_1.test.beforeEach(function () {
    scandit_sdk_1.CameraAccess.cameras = undefined;
    window.MediaStreamTrack = undefined;
    window.navigator.enumerateDevices = undefined;
});
ava_1.test.serial("getCameras (errors)", function (t) { return __awaiter(_this, void 0, void 0, function () {
    var error;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                resetStubs();
                return [4 /*yield*/, t.throws(scandit_sdk_1.CameraAccess.getCameras())];
            case 1:
                error = _a.sent();
                t.is(error.name, "UnsupportedBrowserError");
                t["false"](getUserMediaStub.called);
                t["false"](getSourcesStub.called);
                fakeCompatibleBrowser();
                window.navigator.mediaDevices.getUserMedia = getUserMediaStub.rejects(new Error("Test error"));
                resetStubs();
                return [4 /*yield*/, t.throws(scandit_sdk_1.CameraAccess.getCameras())];
            case 2:
                error = _a.sent();
                t.is(error.message, "Test error");
                t["true"](getUserMediaStub.called);
                t["false"](getSourcesStub.called);
                return [2 /*return*/];
        }
    });
}); });
ava_1.test.serial("getCameras (MediaStreamTrack.getSources)", function (t) { return __awaiter(_this, void 0, void 0, function () {
    var error, cameras, camerasCached;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                fakeCompatibleBrowser();
                // Intentionally wrong legacy method
                window.MediaStreamTrack = {
                    getSources: getSourcesStub.callsArgWith(0, null)
                };
                resetStubs();
                return [4 /*yield*/, t.throws(scandit_sdk_1.CameraAccess.getCameras())];
            case 1:
                error = _a.sent();
                t.is(error.name, "UnsupportedBrowserError");
                t["true"](getUserMediaStub.called);
                t["true"](getSourcesStub.called);
                window.MediaStreamTrack = {
                    getSources: getSourcesStub.callsArgWith(0, [
                        fakeCamera1,
                        fakeCamera2,
                        legacyFakeCamera1,
                        legacyFakeCamera2,
                        fakeMicrophone
                    ])
                };
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 2:
                cameras = _a.sent();
                t["true"](getUserMediaStub.called);
                t["true"](getSourcesStub.called);
                t.not(cameras, null);
                t.is(cameras.length, 4);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 3:
                camerasCached = _a.sent();
                t["false"](getUserMediaStub.called);
                t["false"](getSourcesStub.called);
                t.deepEqual(cameras, camerasCached);
                t.is(cameras[0].deviceId, fakeCamera1.deviceId);
                t.is(cameras[0].label, fakeCamera1.label);
                t.is(cameras[0].cameraType, scandit_sdk_1.Camera.Type.BACK);
                t.is(cameras[0].currentResolution, undefined);
                t.is(cameras[1].deviceId, fakeCamera2.deviceId);
                t.is(cameras[1].label, fakeCamera2.label);
                t.is(cameras[1].cameraType, scandit_sdk_1.Camera.Type.FRONT);
                t.is(cameras[1].currentResolution, undefined);
                t.is(cameras[2].deviceId, "");
                t.is(cameras[2].label, legacyFakeCamera1.label);
                t.is(cameras[2].cameraType, scandit_sdk_1.Camera.Type.BACK);
                t.is(cameras[2].currentResolution, undefined);
                t.is(cameras[3].deviceId, legacyFakeCamera2.deviceId);
                t.is(cameras[3].label, legacyFakeCamera2.label);
                t.is(cameras[3].cameraType, scandit_sdk_1.Camera.Type.FRONT);
                t.is(cameras[3].currentResolution, undefined);
                return [2 /*return*/];
        }
    });
}); });
ava_1.test.serial("getCameras (navigator.mediaDevices.enumerateDevices)", function (t) { return __awaiter(_this, void 0, void 0, function () {
    var cameras, camerasCached;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                fakeCompatibleBrowser();
                window.navigator.mediaDevices.enumerateDevices = enumerateDevicesStub.resolves([
                    fakeCamera1,
                    fakeCamera2,
                    illegalFakeCamera1,
                    fakeMicrophone
                ]);
                window.MediaStreamTrack = {
                    getSources: getSourcesStub
                };
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 1:
                cameras = _a.sent();
                t["true"](getUserMediaStub.called);
                t["true"](enumerateDevicesStub.called);
                t["false"](getSourcesStub.called);
                t.not(cameras, null);
                t.is(cameras.length, 3);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 2:
                camerasCached = _a.sent();
                t["false"](getUserMediaStub.called);
                t["false"](enumerateDevicesStub.called);
                t["false"](getSourcesStub.called);
                t.deepEqual(cameras, camerasCached);
                t.is(cameras[0].deviceId, fakeCamera1.deviceId);
                t.is(cameras[0].label, fakeCamera1.label);
                t.is(cameras[0].cameraType, scandit_sdk_1.Camera.Type.BACK);
                t.is(cameras[0].currentResolution, undefined);
                t.is(cameras[1].deviceId, fakeCamera2.deviceId);
                t.is(cameras[1].label, fakeCamera2.label);
                t.is(cameras[1].cameraType, scandit_sdk_1.Camera.Type.FRONT);
                t.is(cameras[1].currentResolution, undefined);
                t.is(cameras[2].deviceId, illegalFakeCamera1.deviceId);
                t.is(cameras[2].label, "");
                t.is(cameras[2].cameraType, scandit_sdk_1.Camera.Type.FRONT);
                t.is(cameras[2].currentResolution, undefined);
                return [2 /*return*/];
        }
    });
}); });
ava_1.test.serial("getCameras (navigator.enumerateDevices)", function (t) { return __awaiter(_this, void 0, void 0, function () {
    var cameras, camerasCached;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                fakeCompatibleBrowser();
                window.navigator.enumerateDevices = enumerateDevicesStub.resolves([
                    fakeCamera1,
                    fakeCamera2,
                    illegalFakeCamera1,
                    fakeMicrophone
                ]);
                window.navigator.mediaDevices.enumerateDevices = enumerateDevicesStub.resolves([
                    fakeCamera1,
                    fakeCamera2,
                    illegalFakeCamera1,
                    fakeMicrophone
                ]);
                window.MediaStreamTrack = {
                    getSources: getSourcesStub
                };
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 1:
                cameras = _a.sent();
                t["true"](getUserMediaStub.called);
                t["true"](enumerateDevicesStub.called);
                t["false"](getSourcesStub.called);
                t.not(cameras, null);
                t.is(cameras.length, 3);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 2:
                camerasCached = _a.sent();
                t["false"](getUserMediaStub.called);
                t["false"](enumerateDevicesStub.called);
                t["false"](getSourcesStub.called);
                t.deepEqual(cameras, camerasCached);
                t.is(cameras[0].deviceId, fakeCamera1.deviceId);
                t.is(cameras[0].label, fakeCamera1.label);
                t.is(cameras[0].cameraType, scandit_sdk_1.Camera.Type.BACK);
                t.is(cameras[0].currentResolution, undefined);
                t.is(cameras[1].deviceId, fakeCamera2.deviceId);
                t.is(cameras[1].label, fakeCamera2.label);
                t.is(cameras[1].cameraType, scandit_sdk_1.Camera.Type.FRONT);
                t.is(cameras[1].currentResolution, undefined);
                t.is(cameras[2].deviceId, illegalFakeCamera1.deviceId);
                t.is(cameras[2].label, "");
                t.is(cameras[2].cameraType, scandit_sdk_1.Camera.Type.FRONT);
                t.is(cameras[2].currentResolution, undefined);
                return [2 /*return*/];
        }
    });
}); });
ava_1.test.serial("getCameras (internationalized label)", function (t) { return __awaiter(_this, void 0, void 0, function () {
    var cameras;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                fakeCompatibleBrowser();
                window.navigator.mediaDevices.enumerateDevices = enumerateDevicesStub.resolves([fakeCamera3]);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 1:
                cameras = _a.sent();
                t.not(cameras, null);
                t.is(cameras.length, 1);
                t.is(cameras[0].deviceId, fakeCamera3.deviceId);
                t.is(cameras[0].label, fakeCamera3.label);
                t.is(cameras[0].cameraType, scandit_sdk_1.Camera.Type.BACK);
                t.is(cameras[0].currentResolution, undefined);
                return [2 /*return*/];
        }
    });
}); });
ava_1.test.serial("getCameras (no front/back label information)", function (t) { return __awaiter(_this, void 0, void 0, function () {
    var cameras;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                fakeCompatibleBrowser();
                window.navigator.mediaDevices.enumerateDevices = enumerateDevicesStub.resolves([fakeCamera4, fakeCamera5]);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.getCameras()];
            case 1:
                cameras = _a.sent();
                t.not(cameras, null);
                t.is(cameras.length, 2);
                t.is(cameras[0].deviceId, fakeCamera4.deviceId);
                t.is(cameras[0].label, fakeCamera4.label);
                t.is(cameras[0].cameraType, scandit_sdk_1.Camera.Type.FRONT);
                t.is(cameras[0].currentResolution, undefined);
                t.is(cameras[1].deviceId, fakeCamera5.deviceId);
                t.is(cameras[1].label, fakeCamera5.label);
                t.is(cameras[1].cameraType, scandit_sdk_1.Camera.Type.BACK);
                t.is(cameras[1].currentResolution, undefined);
                return [2 /*return*/];
        }
    });
}); });
// tslint:disable-next-line:max-func-body-length
ava_1.test.serial("accessCameraStream", function (t) { return __awaiter(_this, void 0, void 0, function () {
    var mediaStream, fakeCamera;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                fakeCompatibleBrowser();
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(0)];
            case 1:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: true
                });
                t.not(mediaStream, null);
                fakeCamera = {
                    deviceId: fakeCamera1.deviceId,
                    label: fakeCamera1.label,
                    cameraType: scandit_sdk_1.Camera.Type.BACK
                };
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(0, fakeCamera)];
            case 2:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: {
                        deviceId: {
                            exact: fakeCamera.deviceId
                        },
                        width: {
                            min: 1400,
                            ideal: 1920,
                            max: 1920
                        },
                        height: {
                            min: 900,
                            ideal: 1440,
                            max: 1440
                        }
                    }
                });
                t.not(mediaStream, null);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(1, fakeCamera)];
            case 3:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: {
                        deviceId: {
                            exact: fakeCamera.deviceId
                        },
                        width: {
                            min: 1200,
                            ideal: 1920,
                            max: 1920
                        },
                        height: {
                            min: 900,
                            ideal: 1200,
                            max: 1200
                        }
                    }
                });
                t.not(mediaStream, null);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(2, fakeCamera)];
            case 4:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: {
                        deviceId: {
                            exact: fakeCamera.deviceId
                        },
                        width: {
                            min: 1080,
                            ideal: 1920,
                            max: 1920
                        },
                        height: {
                            min: 900,
                            ideal: 1080,
                            max: 1080
                        }
                    }
                });
                t.not(mediaStream, null);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(3, fakeCamera)];
            case 5:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: {
                        deviceId: {
                            exact: fakeCamera.deviceId
                        },
                        width: {
                            min: 960,
                            ideal: 1280,
                            max: 1440
                        },
                        height: {
                            min: 480,
                            ideal: 960,
                            max: 960
                        }
                    }
                });
                t.not(mediaStream, null);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(4, fakeCamera)];
            case 6:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: {
                        deviceId: {
                            exact: fakeCamera.deviceId
                        },
                        width: {
                            min: 720,
                            ideal: 1280,
                            max: 1440
                        },
                        height: {
                            min: 480,
                            ideal: 720,
                            max: 768
                        }
                    }
                });
                t.not(mediaStream, null);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(5, fakeCamera)];
            case 7:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: {
                        deviceId: {
                            exact: fakeCamera.deviceId
                        },
                        width: {
                            min: 640,
                            ideal: 960,
                            max: 1440
                        },
                        height: {
                            min: 480,
                            ideal: 720,
                            max: 720
                        }
                    }
                });
                t.not(mediaStream, null);
                resetStubs();
                return [4 /*yield*/, scandit_sdk_1.CameraAccess.accessCameraStream(6, fakeCamera)];
            case 8:
                mediaStream = _a.sent();
                t["true"](getUserMediaStub.called);
                t.deepEqual(getUserMediaStub.args[0][0], {
                    audio: false,
                    video: {
                        deviceId: {
                            exact: fakeCamera.deviceId
                        }
                    }
                });
                return [2 /*return*/];
        }
    });
}); });
