import { BrowserHelper } from "./browserHelper";
import { Camera } from "./camera";
import { CustomError } from "./customError";

/**
 * A helper object to interact with cameras.
 */
export namespace CameraAccess {
  /**
   * @hidden
   *
   * Handle localized camera labels. Supported languages:
   * English, German, French, Spanish (spain), Portuguese (brasil), Portuguese (portugal), Italian,
   * Chinese (simplified), Chinese (traditional), Japanese, Russian, Turkish, Dutch, Arabic, Thai, Swedish,
   * Danish, Vietnamese, Norwegian, Polish, Finnish, Indonesian, Hebrew, Greek, Romanian, Hungarian, Czech,
   * Catalan, Slovak, Ukraininan, Croatian, Malay, Hindi.
   */
  const backCameraKeywords: string[] = [
    "rear",
    "back",
    "rück",
    "arrière",
    "trasera",
    "trás",
    "traseira",
    "posteriore",
    "后面",
    "後面",
    "背面",
    "后置", // alternative
    "後置", // alternative
    "背置", // alternative
    "задней",
    "الخلفية",
    "후",
    "arka",
    "achterzijde",
    "หลัง",
    "baksidan",
    "bagside",
    "sau",
    "bak",
    "tylny",
    "takakamera",
    "belakang",
    "אחורית",
    "πίσω",
    "spate",
    "hátsó",
    "zadní",
    "darrere",
    "zadná",
    "задня",
    "stražnja",
    "belakang",
    "बैक"
  ];

  /**
   * @hidden
   */
  export let cameras: Camera[];

  /**
   * Get a list of cameras (if any) available on the device, a camera access permission is requested to the user
   * the first time this method is called if needed. Subsequent calls return a cached list of cameras.
   *
   * Depending on device features and user permissions for camera access, any of the following errors
   * could be the rejected result of the returned promise:
   * - <tt>UnsupportedBrowserError</tt>
   * - <tt>PermissionDeniedError</tt>
   * - <tt>NotAllowedError</tt>
   * - <tt>NotFoundError</tt>
   * - <tt>AbortError</tt>
   * - <tt>NotReadableError</tt>
   * - <tt>InternalError</tt>
   *
   * @returns A promise resolving to the array of available [[Camera]] objects (could be empty).
   */
  export function getCameras(): Promise<Camera[]> {
    return new Promise((resolve, reject) => {
      const unsupportedBrowserError: Error | undefined = BrowserHelper.checkBrowserCompatibility();
      if (unsupportedBrowserError != null) {
        return reject(unsupportedBrowserError);
      }
      if (cameras != null) {
        return resolve(cameras);
      }

      navigator.mediaDevices
        .getUserMedia({
          video: true,
          audio: false
        })
        .then(stream => {
          return enumerateDevices()
            .then(devices => {
              stream.getVideoTracks().forEach(track => {
                track.stop();
              });

              cameras = devices
                .filter(device => {
                  return device.kind === "videoinput";
                })
                .map(videoDevice => {
                  const label: string = videoDevice.label != null ? videoDevice.label : "";
                  const lowercaseLabel: string = label.toLowerCase();

                  return {
                    deviceId: videoDevice.deviceId,
                    label: label,
                    cameraType: backCameraKeywords.some(keyword => {
                      return lowercaseLabel.indexOf(keyword) !== -1;
                    })
                      ? Camera.Type.BACK
                      : Camera.Type.FRONT
                  };
                });
              if (
                cameras.length > 1 &&
                !cameras.some(camera => {
                  return camera.cameraType === Camera.Type.BACK;
                })
              ) {
                const camera: Camera = cameras.slice(-1)[0];
                cameras[cameras.length - 1] = {
                  deviceId: camera.deviceId,
                  label: camera.label,
                  cameraType: Camera.Type.BACK
                };
              }

              return resolve(cameras);
            })
            .catch(error => {
              stream.getVideoTracks().forEach(track => {
                track.stop();
              });

              return reject(error);
            });
        })
        .catch(error => {
          reject(error);
        });
    });
  }

  /**
   * @hidden
   *
   * Try to access a given camera for video input at the given resolution level.
   *
   * @param resolutionFallbackLevel The number representing the wanted resolution, from 0 to 6,
   * resulting in higher to lower video resolutions.
   * @param camera The camera to try to access for video input.
   * @returns A promise resolving to the <tt>MediaStream</tt> object coming from the accessed camera.
   */
  export function accessCameraStream(resolutionFallbackLevel: number, camera?: Camera): Promise<MediaStream> {
    const getUserMediaParams: any = {
      audio: false,
      video: {}
    };
    if (resolutionFallbackLevel === 0) {
      getUserMediaParams.video = {
        width: {
          min: 1400,
          ideal: 1920,
          max: 1920
        },
        height: {
          min: 900,
          ideal: 1440,
          max: 1440
        }
      };
    } else if (resolutionFallbackLevel === 1) {
      getUserMediaParams.video = {
        width: {
          min: 1200,
          ideal: 1920,
          max: 1920
        },
        height: {
          min: 900,
          ideal: 1200,
          max: 1200
        }
      };
    } else if (resolutionFallbackLevel === 2) {
      getUserMediaParams.video = {
        width: {
          min: 1080,
          ideal: 1920,
          max: 1920
        },
        height: {
          min: 900,
          ideal: 1080,
          max: 1080
        }
      };
    } else if (resolutionFallbackLevel === 3) {
      getUserMediaParams.video = {
        width: {
          min: 960,
          ideal: 1280,
          max: 1440
        },
        height: {
          min: 480,
          ideal: 960,
          max: 960
        }
      };
    } else if (resolutionFallbackLevel === 4) {
      getUserMediaParams.video = {
        width: {
          min: 720,
          ideal: 1280,
          max: 1440
        },
        height: {
          min: 480,
          ideal: 720,
          max: 768
        }
      };
    } else if (resolutionFallbackLevel === 5) {
      getUserMediaParams.video = {
        width: {
          min: 640,
          ideal: 960,
          max: 1440
        },
        height: {
          min: 480,
          ideal: 720,
          max: 720
        }
      };
    }

    if (camera === undefined) {
      getUserMediaParams.video = true;
    } else {
      getUserMediaParams.video.deviceId = {
        exact: camera.deviceId
      };
    }

    return navigator.mediaDevices.getUserMedia(getUserMediaParams);
  }

  /**
   * @hidden
   *
   * Get a list of available devices in a cross-browser compatible way.
   *
   * @returns A promise resolving to the <tt>MediaDeviceInfo</tt> array of all available devices.
   */
  function enumerateDevices(): Promise<MediaDeviceInfo[]> {
    if (typeof (<any>window.navigator).enumerateDevices === "function") {
      return (<any>window.navigator).enumerateDevices();
    } else if (
      typeof (<any>window.navigator).mediaDevices === "object" &&
      typeof (<any>window.navigator).mediaDevices.enumerateDevices === "function"
    ) {
      return window.navigator.mediaDevices.enumerateDevices();
    } else {
      return new Promise((resolve, reject) => {
        try {
          (<any>window).MediaStreamTrack.getSources((devices: MediaDeviceInfo[]) => {
            resolve(
              devices
                .filter(device => {
                  return device.kind.toLowerCase() === "video" || device.kind.toLowerCase() === "videoinput";
                })
                .map(device => {
                  return {
                    deviceId: device.deviceId != null ? device.deviceId : "",
                    groupId: device.groupId,
                    kind: <MediaDeviceKind>"videoinput",
                    label: device.label
                  };
                })
            );
          });
        } catch (error) {
          reject(
            new CustomError({
              name: "UnsupportedBrowserError",
              message: "Media devices are not supported on this OS / Browser"
            })
          );
        }
      });
    }
  }
}
